var FloatingBall = function(x, y){	this.x = x;	this.y = y;		//Callback restoring idle animation.	this.actionCallback = cc.CallFunc.create(function(node){								this.swapAnimation(Enum.Anim.Type.IDLE);							}, this);		cc.SpriteFrameCache.getInstance().addSpriteFrames(assetsWinningGoalDir + 'floatingBall_idle.plist', 												      assetsWinningGoalDir + 'floatingBall_idle.png');	cc.SpriteFrameCache.getInstance().addSpriteFrames(assetsWinningGoalDir + 'floatingBall_action.plist', 												      assetsWinningGoalDir + 'floatingBall_action.png');		this.currentAnimationType = Enum.Anim.Type.IDLE;		//Base frame.	this.currentAnimation = cc.Sprite.createWithSpriteFrameName('floatingBall_idle.0000.png');	this.currentAnimation.setPosition(new cc.Point(x, y));	this.currentAnimation._zOrder = 1000;		//Idle.	var idleAnimFrames = [];	var str = "";	for (var i = 0; i < 24; i++) {		str = "floatingBall_idle." + (i < 10 ? ("000" + i) : ('00' + i)) + ".png";		var frame = cc.SpriteFrameCache.getInstance().getSpriteFrame(str);		idleAnimFrames.push(frame);	}	//Creation of the idle animation.	var animation = cc.Animation.create(idleAnimFrames, 0.042);	this.idleAnimation = cc.Animate.create(animation);		//Action animation.	var actionAnimFrames = [];	for (var i = 24; i < 44; i++) {		str = "floatingBall_action.00" + i + ".png";		var frame = cc.SpriteFrameCache.getInstance().getSpriteFrame(str);		actionAnimFrames.push(frame);	}		//Creation of the action animation.	animation = cc.Animation.create(actionAnimFrames, 0.042);	this.actionAnimation = cc.Animate.create(animation);		this.currentAnimation.runAction(cc.RepeatForever.create(this.idleAnimation));};FloatingBall.prototype.swapAnimation = function(animType){		if(animType != this.currentAnimationType)	{		Client.layer.removeChild(this.currentAnimation);				switch(animType)		{			case Enum.Anim.Type.IDLE:				this.currentAnimation.runAction(cc.RepeatForever.create(this.idleAnimation));				break;			case Enum.Anim.Type.GOAL_ACTION:				//Create a sequence that will restore idle animation at the end.				this.currentAnimation.runAction(cc.Sequence.create(this.actionAnimation, 																   this.actionCallback));				break;		}				this.currentAnimationType = animType;				Client.layer.addChild(this.currentAnimation);	}};FloatingBall.prototype.fromServer = function(data){	this.x = data.x;	this.y = data.y;		this.currentAnimation.setPosition(new cc.Point(this.x, this.y));};