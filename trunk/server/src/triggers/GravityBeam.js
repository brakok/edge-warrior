var GravityBeam = function(x, y, width, height, duration, maxLiftHeight, timeAllowed, impulse, game){		this.id = -1;		this.type = Enum.Trigger.Type.GRAVITY_BEAM;	this.x = x;	this.y = y;	this.width = width;	this.height = height;		this.duration = duration;	this.maxLiftHeight = maxLiftHeight;	this.timeAllowed = timeAllowed;		this.impulse = impulse;	this.currentGame = game;		this.players = {};	this.stillExists = true;	//Create body.	this.body = new chipmunk.Body(Infinity, Infinity);	this.body.setPos(new chipmunk.Vect(this.x, this.y));		//Assign custom data to body.	this.body.userdata = {		type: Enum.UserData.Type.GRAVITY_BEAM,		object: this	};		//Create a shape associated with the body.	this.shape = this.currentGame.space.addShape(chipmunk.BoxShape(this.body, this.width, this.height));	this.shape.setCollisionType(Enum.Collision.Type.TRIGGER);	this.shape.sensor = true;};GravityBeam.prototype.toClient = function(){	return {		id: this.id,		x: this.x,		y: this.y	};};//Called when contact begins.GravityBeam.prototype.onBegin = function(player, block){	//Prevent player to abuse the gravity beam.	if(player != null && this.players[player.id] != null)	{		var currentTime = new Date();		var dt = (currentTime - this.players[player.id].cooldown)*0.001;				if(dt < Constants.Trigger.GravityBeam.COOLDOWN)		{			this.players[player.id].lift = true;			return;		}					delete this.players[player.id];	}	//Keep track.	if(player != null && this.players[player.id] == null)	{		this.players[player.id] = {			target: player,			x: player.x,			y: player.y,			timer: this.timeAllowed,			cooldown: new Date(),			lift: true		};				//io.sockets.in(this.currentGame.id).emit(Constants.Message.ACTION_TRIGGER, { id: this.id, type: Enum.Trigger.Action.Type.COMMON });	}};//Called when contact ends.GravityBeam.prototype.onEnd = function(player, block){		if(player != null && this.players[player.id] != null)		this.players[player.id].lift = false;};GravityBeam.prototype.update = function(){	for(var i in this.players)		if(this.players[i] && this.players[i].lift)		{			//Continue if player is removed.			if(this.players[i].target.isRemoved)			{				delete this.players[i];				continue;			}					this.players[i].timer -= this.currentGame.dt;			var dt = this.players[i].target.y - this.players[i].y;									if(this.players[i].timer <= 0 || dt >= this.maxLiftHeight)			{				this.currentGame.overlord.assignKill(this.players[i].target);				delete this.players[i];			}			else			{				if(this.players[i].target.body.getVel().y < Constants.Trigger.GravityBeam.MAX_VEL_Y)					this.players[i].target.body.applyImpulse(new chipmunk.Vect(0, this.impulse), new chipmunk.Vect(0,0));				else					this.players[i].target.body.setVel(new chipmunk.Vect(this.players[i].target.body.getVel().x, Constants.Trigger.GravityBeam.MAX_VEL_Y));			}		}	this.duration -= this.currentGame.dt;		if(this.duration <= 0)		this.stillExists = false;};GravityBeam.prototype.explode = function(){	//Remove physical presence.	this.currentGame.space.removeShape(this.shape);				var data = {		id: this.id	};		//Send info to client.	this.stillExists = false;	io.sockets.in(this.currentGame.id).emit(Constants.Message.DELETE_TRIGGER, data);};